<html lang="en"><head>
  
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">
  
  <title>The Bitter Lesson is coming for Tokenization | ‚õ∞Ô∏è lucalp</title>
  <link rel="canonical" href="https://lucalp.dev/bitter-lesson-tokenization-and-blt/">
  
    

    <meta name="lucalp" content="look-for-the-bear-necessities">

    <!-- Primary Meta Tags -->
<meta name="title" content="The Bitter Lesson is coming for Tokenization">
<meta name="description" content="Highlights the desire to replace tokenization with a general method that better leverages compute and data. We'll see tokenization's fragility and review the Byte Latent Transformer arch.">

<!-- Open Graph / Facebook -->
<meta property="og:site_name" content="‚õ∞Ô∏è lucalp">
<meta property="og:title" content="The Bitter Lesson is coming for Tokenization">
<meta property="og:type" content="article">
<meta property="og:url" content="https://lucalp.dev/bitter-lesson-tokenization-and-blt/">
<meta property="og:description" content="Highlights the desire to replace tokenization with a general method that better leverages compute and data. We'll see tokenization's fragility and review the Byte Latent Transformer arch.">
<meta property="og:image" content="https://bear-images.sfo2.cdn.digitaloceanspaces.com/herman-1683556668-0.png">


<!-- Twitter -->
<meta property="twitter:card" content="summary">
<meta property="twitter:url" content="https://lucalp.dev/bitter-lesson-tokenization-and-blt/">
<meta property="twitter:title" content="The Bitter Lesson is coming for Tokenization">
<meta property="twitter:description" content="Highlights the desire to replace tokenization with a general method that better leverages compute and data. We'll see tokenization's fragility and review the Byte Latent Transformer arch.">
<meta property="twitter:image" content="https://bear-images.sfo2.cdn.digitaloceanspaces.com/herman-1683556668-0.png">



<!-- Microdata -->
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "article",
    "name": "The Bitter Lesson is coming for Tokenization",
    "url": "https://lucalp.dev/bitter-lesson-tokenization-and-blt/",
    "description": "Highlights the desire to replace tokenization with a general method that better leverages compute and data. We&#x27;ll see tokenization&#x27;s fragility and review the Byte Latent Transformer arch.",
    "about": {
      "@type": "The Bitter Lesson is coming for Tokenization",
      "description": "Highlights the desire to replace tokenization with a general method that better leverages compute and data. We&#x27;ll see tokenization&#x27;s fragility and review the Byte Latent Transformer arch."
    }
  }
</script>

  
    
 <script defer="" src="https://cdn.usefathom.com/script.js" data-site="LXASJQFF"></script>
<script>
        // Ensure Fathom is loaded before we try to use it.
        // This is important because the Fathom script is loaded with `defer`.
        document.addEventListener('DOMContentLoaded', () => {

            // Check if fathom is available on the window object.
            if (typeof fathom === 'undefined') {
                console.error('Fathom Analytics script not found. Scroll tracking disabled.');
                return;
            }

            // --- Configuration ---
            // Define the scroll percentage milestones you want to track.
            const scrollMilestones = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100];
            
            // This array will keep track of the milestones we've already logged for this page view
            // to prevent sending the same event multiple times.
            let loggedMilestones = [];

            // A flag to prevent the scroll handler from running too often.
            let isThrottled = false;

            // --- Scroll Tracking Logic ---
            const handleScroll = () => {
                // Get the total height of the document's body.
                const docHeight = document.body.scrollHeight;
                // Get the height of the browser window.
                const windowHeight = window.innerHeight;
                // Get the current vertical scroll position.
                const scrollPosition = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;

                // Calculate the total scrollable height.
                const totalScrollableHeight = docHeight - windowHeight;
                
                // Avoid division by zero on pages that don't scroll.
                if (totalScrollableHeight <= 0) {
                    return;
                }

                // Calculate the current scroll percentage.
                const scrollPercentage = Math.round((scrollPosition / totalScrollableHeight) * 100);

                // Check against each milestone.
                scrollMilestones.forEach(milestone => {
                    // If the user has scrolled past the milestone and it hasn't been logged yet...
                    if (scrollPercentage >= milestone && !loggedMilestones.includes(milestone)) {
                        
                        // Construct the event name.
                        const eventName = `bitter-lesson-tokenization-and-blt scroll-depth ${milestone}%`;
                        
                        // Log the event to Fathom. The '0' indicates no monetary value.
                        // Since this is a simple event, we don't need a value, but fathom.trackEvent requires a second argument.
                        fathom.trackEvent(eventName);

                        // For debugging: log to the console to confirm the event was sent.
                        console.log(`Fathom event tracked: ${eventName}`);

                        // Add the milestone to our list of logged milestones.
                        loggedMilestones.push(milestone);
                    }
                });
            };

            // --- Event Listener ---
            // We throttle the scroll event to improve performance.
            // The event will only be processed every 250 milliseconds.
            window.addEventListener('scroll', () => {
                if (!isThrottled) {
                    window.requestAnimationFrame(() => {
                        handleScroll();
                        isThrottled = false;
                    });
                    isThrottled = true;
                }
            }, { passive: true });
        });
    </script>
 <style>
    figcaption {text-align:center;}
    .small-caps{font-feature-settings: "smcp"; font-variant-caps: small-caps;}
    :root {--width:56rem !important; }
    img {display: block; margin: 0 auto; margin-top: 30px; margin-bottom: 30px}
iframe {
  width: 80vw;
  margin-top:10px;
  margin-bottom:10px;
  height: 80vh; /* Height for screens under 768px */
  margin-left: calc(50% - 40vw);
    border: 1px dashed black;
    padding: 10px;
}

@media (prefers-color-scheme: dark) {
  iframe {
    border: 1px dashed #DDDDDD;
  }
}

/* Media query for tablets and desktops (768px and wider) */
@media (min-width: 768px) {
  iframe {
    height: 600px; /* Height for screens 768px and wider */
  }
}

@media (min-width: 600px) {
    math[display="block" i] {
        font-size:1.3rem !important;
    }
}

math[display="inline" i] {
    display: math;
    math-style: compact;
    font-size: 1.2rem;
}
math[display="block" i] {
    display: block math;
    math-style: normal;
    font-size:1rem;
}
main > p:first-of-type {
  display: none;
}

.container-cite {
            width: 100%;
            max-width: 650px;
        }

        h2 {
            font-size: 1.25rem;
            font-weight: 500;
            margin-bottom: 1rem;
            color: #1e293b; /* Tailwind's slate-800 */
        }

        .citation-box-plain {
            line-height: 1.6;
            color: #334155; /* slate-700 */
            background-color: #f1f5f9; /* slate-100 */
            border: 1px solid #e2e8f0; /* slate-200 */
            border-radius: 0.5rem; /* 8px */
            padding: 1.5rem; /* 24px */
            position: relative;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05);
        }

        .citation-box-plain pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .copy-btn-plain {
            position: absolute;
            top: 1rem; /* 16px */
            right: 1rem; /* 16px */
            padding: 0.5rem; /* 8px */
            border-radius: 0.375rem; /* 6px */
            background-color: #e2e8f0; /* slate-200 */
            color: #475569; /* slate-600 */
            border: none;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        .copy-btn-plain:hover {
            background-color: #cbd5e1; /* slate-300 */
            transform: scale(1.05);
        }
        
        .copy-btn-plain.copied {
            background-color: #d1fae5; /* green-100 */
            color: #059669; /* green-600 */
        }
  </style>
  <script>
document.addEventListener("DOMContentLoaded", function() {
  const lazyIframes = document.querySelectorAll('.lazy-iframe');

  if ("IntersectionObserver" in window) {
    const iframeObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const iframe = entry.target;
          iframe.src = iframe.dataset.src;
          iframe.classList.remove('lazy-iframe');
          observer.unobserve(iframe); // Stop observing the iframe once loaded
        }
      });
    }, {
      // Trigger the observer when the iframe is 200px away from the viewport
      rootMargin: '200px 0px 200px 0px'
    });

    lazyIframes.forEach(iframe => {
      iframeObserver.observe(iframe);
    });
  } else {
    // Fallback for older browsers
    lazyIframes.forEach(iframe => {
      iframe.src = iframe.dataset.src;
      iframe.classList.remove('lazy-iframe');
    });
  }
});

</script>
<link rel="shortcut icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3E%3Ctext%20y='.9em'%20font-size='90'%3E‚õ∞Ô∏è%3C/text%3E%3C/svg%3E"><style>
      
      
    
:root {
    --width: 720px;
    --font-main: Verdana, sans-serif;
    --font-secondary: Verdana, sans-serif;
    --font-scale: 1em;
    --background-color: #fff;
    --heading-color: #222;
    --text-color: #444;
    --link-color: #3273dc;
    --visited-color:  #8b6fcb;
    --code-background-color: #f2f2f2;
    --code-color: #222;
    --blockquote-color: #222;
}

@media (prefers-color-scheme: dark) {
    :root {
        --background-color: #01242e;
        --heading-color: #eee;
        --text-color: #ddd;
        --link-color: #8cc2dd;
        --visited-color:  #8b6fcb;
        --code-background-color: #000;
        --code-color: #ddd;
        --blockquote-color: #ccc;
    }
}

body {
    font-family: var(--font-secondary);
    font-size: var(--font-scale);
    margin: auto;
    padding: 20px;
    max-width: var(--width);
    text-align: left;
    background-color: var(--background-color);
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: var(--text-color);
}

h1, h2, h3, h4, h5, h6 {
    font-family: var(--font-main);
    color: var(--heading-color);
}

a {
    color: var(--link-color);
    cursor: pointer;
    text-decoration: none;
}

a:hover {
    text-decoration: underline; 
}

nav a {
    margin-right: 8px;
}

strong, b {
    color: var(--heading-color);
}

button {
    margin: 0;
    cursor: pointer;
}

time {
 	font-family: monospace;
  	font-style: normal;
  	font-size: 15px;
}

main {
    line-height: 1.6;
}

table {
    width: 100%;
}

hr {
    border: 0;
    border-top: 1px dashed;
}

img {
    max-width: 100%;
}

code {
    font-family: monospace;
    padding: 2px;
    background-color: var(--code-background-color);
    color: var(--code-color);
    border-radius: 3px;
}

blockquote {
    border-left: 1px solid #999;
    color: var(--code-color);
    padding-left: 20px;
    font-style: italic;
}

footer {
    padding: 25px 0;
    text-align: center;
}

.title:hover {
    text-decoration: none;
}

.title h1 {
    font-size: 1.5em;
}

.inline {
    width: auto !important;
}

.highlight, .code {
    padding: 1px 15px;
    background-color: var(--code-background-color);
    color: var(--code-color);
    border-radius: 3px;
    margin-block-start: 1em;
    margin-block-end: 1em;
    overflow-x: auto;
}

/* blog post list */
ul.blog-posts {
    list-style-type: none;
    padding: unset;
}

ul.blog-posts li {
    display: flex;
}

ul.blog-posts li span {
    flex: 0 0 130px;
}

ul.blog-posts li a:visited {
    color: var(--visited-color);
}
    .upvote-button {
        padding: 0;
        margin: 0;
        border: 0;
        background-color: inherit;
        color: inherit;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .upvote-button.upvoted {
        color: salmon;
    }
    .upvote-count {
        margin-top: -3px;
    }

      
  </style><style>
        body:hover {
            shape-outside: url("/hit/DneoHENPEMtzwxeNzfjU/?ref=https://news.ycombinator.com/");
        }
    </style></head>

    
    
  
  
  
    
        
    



  

  
    
    
    



<body class="post " onload="(function() { document.cookie = `timezone=${Intl.DateTimeFormat().resolvedOptions().timeZone};path=/`; })()" style="max-width: 896px; transition: max-width 0.5s ease-in-out;">
  
  <header>
    <a class="title" href="/">
      <h1>
        ‚õ∞Ô∏è lucalp
      </h1>
    </a>
    <nav>
      <p><a href="/">Home</a> <a href="/blog/">Blog</a> <a href="/bio/">Bio</a> <a href="https://x.com/lucalp__">Twitter</a></p>

    </nav>
  </header>
  <main>
    

    
        
    

    
        <h1>The Bitter Lesson is coming for Tokenization</h1>

        <p>
            <i>
                <time datetime="2025-06-24T13:30Z">
                    24 Jun, 2025
                </time>
            </i>
        </p>
    

    <p><em>a world of LLMs without tokenization is desirable and increasingly possible</em></p>
<p class="small-caps">Published on 24/06/2025 ‚Ä¢ ‚è±Ô∏è 29 min read</p>
<hr>
<blockquote>
<p>In this post, we highlight the desire to replace tokenization with a general method that better leverages compute and data. We'll see tokenization's role, its fragility and we'll build a case for removing it. After understanding the design space, we'll explore the potential impacts of a recent promising candidate (Byte Latent Transformer) and build strong intuitions around new core mechanics.</p>
</blockquote>
<p>As it's been pointed out countless times - if the trend of ML research could be summarised, it'd be the adherence to <a href="http://www.incompleteideas.net/IncIdeas/BitterLesson.html">The Bitter Lesson</a> - opt for general-purpose methods that leverage large amounts of compute and data over crafted methods by domain experts. More succinctly articulated by <a href="https://x.com/ilyasut">Ilya Sutskever</a>, "the models, they just want to learn". Model ability has continued to be blessed with the talent influx, hardware upgrades, model architectural advances and initial data ubiquity to enable this reality in recent years.</p>
<h2 id="the-pervasive-tokenization-problem">the pervasive tokenization problem</h2><p>However, one of the <a href="https://arxiv.org/abs/2310.08754">documented bottlenecks</a> in the text transformer world that has received less optimisation effort is the very mechanism that shapes its world view - tokenization.</p>
<p>If you're not aware, one of the popular text tokenization methods for transformers, Byte-Pair Encoding (BPE), is <a href="https://huggingface.co/learn/llm-course/en/chapter6/5">a learned procedure</a> that extracts an <em>effectively compressed</em> vocabulary (of desired size) from a dataset by iteratively merging the most frequent pairs of existing tokens.</p>
<figure>
<video style="width:100%; width:100%;max-width: 600px; display: block; margin: auto;" autoplay="" loop="" muted="" playsinline="">
<source src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/hf-bpe-cut.mp4" type="video/mp4">
</video>
<figcaption><a href="https://huggingface.co/learn/llm-course/en/chapter6/5">source</a></figcaption>
</figure>
<p>It's worth remembering that this form of tokenization is <em>not</em> a strict requirement of the transformer. In practice, it means that we're able to represent more bytes given a fixed number of entries in the transformer's embedding table. From our earlier definition, <em>effective</em> is doing some heavy lifting. Ideally, the vocabulary of tokens is perfectly constructed for the task at hand such that it obtains the optimal trade off of byte compression to reduce the transformer's FLOPS while maintaining enough of a granular representation to achieve the lowest possible loss. Another ideal attribute is that tokens that do get merged, end up being well-modelled during training.</p>
<figure>
<img style="
width:100%;max-width: 600px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/tokenizer-map.webp">
<figcaption><i>A crude map of sequence vs vocab size</i></figcaption>
</figure>
<p>In the optimal tradeoff, the need for byte compression comes from attention's <a href="https://proceedings.mlr.press/v201/duman-keles23a.html">computational complexity</a> and it's the core reason why transformers have to rely on some form of tokenization (often sub-word). Character-level RNNs used to be the norm (<a href="https://icml.cc/2011/papers/524_icmlpaper.pdf">Sutskever, 2011</a>, <a href="https://arxiv.org/abs/1308.0850">Graves, 2013</a>, <a href="https://karpathy.github.io/2015/05/21/rnn-effectiveness/#:~:text=use%20an%20LSTM.-,Character%2DLevel%20Language%20Models,-Okay%2C%20so%20we">Karpathy's RNN post</a>) but they struggled to learn from characters and were superseded in favour of character-aware models that tokenize via <a href="https://arxiv.org/abs/1508.06615">a CNN over characters</a> (which also spilled over to <a href="https://arxiv.org/abs/2010.10392">transformer world</a>). In the case of attention however, tokenization was there <a href="https://arxiv.org/html/1706.03762v7#:~:text=a%2032000%20word%2Dpiece%20vocabulary">from the beginning</a> since it is imperative to avoid clogging up the context to enable the transformer to attend to the full sequence and cash in on its <a href="https://arxiv.org/html/1706.03762v7#:~:text=The%20shorter%20these%20paths%20between%20any%20combination%20of%20positions%20in%20the%20input%20and%20output%20sequences%2C%20the%20easier%20it%20is%20to%20learn%20long%2Drange%20dependencies">long-range dependencies abilities</a>.</p>
<p>Revisiting the optimal tradeoff, tokenizers are often far from the ideal and the history of LLMs is plagued with downstream issues attributable to them. From these "earlier" days as modern LLMs started seeing more activity, <a href="https://www.youtube.com/watch?v=zduSFxRajkE">we saw things</a> like:</p>
<ul>
<li>a reddit user "SolidGoldMagikarp" getting <a href="https://www.lesswrong.com/posts/aPeJE8bSo6rAFoLqg/solidgoldmagikarp-plus-prompt-generation">their own dedicated token</a> in OpenAI's tokenizer that was poorly modelled, eliciting the phenomena of <a href="https://arxiv.org/pdf/2402.14020">"glitch tokens"</a></li>
<li>GPT2's Python performance being worse than expected partially due to the way in spaces were tokenized (<a href="https://tiktokenizer.vercel.app/?model=gpt2">paste in &amp; see</a>)</li>
<li>inability to detect the number of <a href="https://letmegooglethat.com/?q=how+many+r%27s+in+strawberry+meme">r's in üçì meme</a></li>
<li>numbers being <a href="https://www.beren.io/2023-02-04-Integer-tokenization-is-insane/">tokenized totally incoherently in GPT2</a> which got rectified <a href="https://www.beren.io/2024-05-11-Integer-tokenization-is-now-much-less-insane/">a few different ways</a> but the jury is <a href="https://arxiv.org/abs/2402.14903">still out</a> on <a href="https://huggingface.co/spaces/huggingface/number-tokenization-blog">what the consensus will be</a>:</li>
</ul>
<figure>
<img style="
width:100%;max-width: 600px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/gpt2_number_composition.webp">
<figcaption><i>GPT2's number tokenization</i></figcaption>
</figure>
<p>In most of these cases, the tokenizer &amp; <a href="https://huggingface.co/learn/llm-course/en/chapter6/4">its pipeline</a> gets <a href="https://arxiv.org/pdf/2402.01035">tweaked</a> and the problems resolved. There've even been efforts to automatically detect <a href="https://arxiv.org/abs/2405.05417">under-trained tokens</a> for glitch tokens. But examples like the üçì meme (and more later in the post) are more fundamental examples of how we're depriving models of information in the name of efficiency via simplistic levers.</p>
<p>For the purpose of this post, we'll limit our exploration to text tokenization but I would be remiss if I didn't mention that tokenization is a feature across all modalities with <a href="https://arxiv.org/abs/2210.13438">modality-specific</a> <a href="https://www.arxiv.org/abs/2412.13061">tokenizers</a> becoming the standard. This comes with its own host of challenges but continues to perpetuate the externalised, separately trained models that <a href="https://arxiv.org/html/2504.08736v1#:~:text=We%20identify%20the%20growing%20complexity%20of%20latent%20space%20as%20the%20key%20factor%20behind%20the%20reconstruction%20vs.%20generation%20dilemma.%20To%20mitigate%20this%2C%20we%20propose%20semantic%20regularization%2C%20which%20aligns%20tokenizer%20features%20with%20semantically%20consistent%20features%20from%20a%20pre%2Dtrained%20visual%20encoder.">have competing concerns</a> and their own <a href="https://arxiv.org/abs/2005.08520">training dynamics</a> which also end up having to be addressed <a href="https://arxiv.org/pdf/2005.00341">incrementally</a>, <a href="https://arxiv.org/pdf/2306.06546">via extension</a> or via <a href="https://arxiv.org/pdf/2309.15505">improved approaches</a>. This is all to say, the problem is evidently non-trivial and has received significant research effort.</p>
<p>In the world of text tokenization, at least from an external point of view (though, not sure about <a href="https://x.com/Dorialexander/status/1913121809110626762">internally</a>), things do seem to have stagnated. Even with this stability, the failure modes of tokenization continue to impede the models. A reasonable question to ask might be - "we have approaches that let us cope with these failure modes, do we really need to solve it?"</p>
<h3 id="can-we-just-ignore-it">can we just ignore it?</h3><p>From earlier days, chain of thought, tool use and RAG all began addressing these issues and more recently, increasingly sophisticated <a href="https://arxiv.org/html/2412.15450v1#:~:text=with%20Phi%203.5%20incorporating%20multilingual%20data%20during%20mid%2Dtraining.%20However%2C%20the%20exact%20composition%20of%20languages%20in%20the%20training%20corpus%20is%20not%20disclosed%20%E2%80%93%20in%20fact%2C%20no%20languages%20are%20explicitly%20listed%2C%20resulting%20in%20a%20lack%20of%20transparency%20regarding%20the%20data%20sources%20and%20training%20procedures.">undisclosed mid/post-training recipes</a> and the move to reasoning-based models continue in this direction. But it begs the question - how much model ability is being left on the table due to poor tokenization? In my view, this includes both <a href="https://arxiv.org/abs/2305.15425">sub-optimal merges</a> for task diversity to misconfiguring the tokenizer <a href="https://arxiv.org/html/2501.16975v2#:~:text=Using%20a%20large%20input%20vocabulary%2C%20we%20achieve%20performance%20comparable%20to%20double%2Dsized%20baselines%20with%20no%20additional%20cost">relative to model capacity</a>. The honest answer here is that no one seems to have publicly investigated this thoroughly (from what I could find). However, the revealed preference of the big labs is in favour of subword-level tokenization and hasn't seen much movement. Given no direct research to consider, we'll use the latest in learned tokenization and byte-level end-to-end learned tokenization to be proxies for understanding what's being left on the table.</p>
<p>While researching for this post, I ended up reading a bit too much into <a href="https://arxiv.org/pdf/2112.10508">the text tokenization literature</a> which probably warrants its own post. For the curious reader, <a href="https://arxiv.org/pdf/2112.10508">this provides a great overview and kick off point</a> but in the interest of my own sanity and your time, just <a href="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/trust-me-bro.webp">trust me bro</a>, there's quite a bit to it!</p>
<h3 id="can-we-just-delete-it">can we just delete it?</h3><p>Before attempting optimising, we should always ask the important question "<a href="https://www.google.co.uk/books/edition/Elon_Musk/HjyvEAAAQBAJ?hl=en&amp;gbpv=1&amp;bsq=delete%20what%20you%20can&amp;printsec=frontcover">can we just delete it?</a>". From a domain point of view, some <a href="https://arxiv.org/pdf/2112.10508">are skeptical</a> that bytes are adequate for modelling natural language. However, if we only entertain the technical feasibility - what does deletion look like?</p>
<p>In <a href="https://arxiv.org/pdf/1808.04444">the GPT-2 paper</a>, the authors revisit the choice of input representation and, empirically, register a similar performance gap on WebText to Google's work in the <a href="https://arxiv.org/abs/1808.04444">character-level LM with Deeper Self-Attention</a> paper. It kicked off the character-level revival by showing that, with the help of auxiliary losses, it outperformed its LSTM character-level counter parts but still registered a gap versus word-level models. The authors follow up with another paper that <a href="https://arxiv.org/pdf/1908.10322">bridges the gap</a> but at the expense of much more compute and time to train.</p>
<p>This is all to say, we started at the character-level, authors tried going back to it but failed for other reasons that may encourage revision due to shifting underlying factors. If we look at BPE more closely, a commonly cited heuristic is that BPE tokens represent, on average, 4.4 bytes per token meaning that current BPE-based transformers' 32K token context windows are able to attend over ~140K bytes with a vocab size of 256K. If we were to use pure bytes and a vanilla transformer modelling UTF-8 bytes, we'd have a vocab size of 256 and be limited to attending to only 32K bytes!</p>
<p>So Google's <a href="https://arxiv.org/abs/2105.13626">ByT5</a> set out to answer the "can we delete?" question in its purest form:</p>
<blockquote>
<p>Our goal in designing ByT5 is to take an existing token-based model and perform the minimal set of modifications to make it token-free, thereby limiting experimental confounds.</p>
</blockquote>
<p>They showed that pure byte modelling, even when trained on 4x less data, had comparable or better performance to its SentencePiece counter part on a subset of benchmarks under 1B parameters (namely robustness to noise, word-level tasks like transliteration, morphological inflection, graphene-to-phoneme<sup class="footnote-ref" id="fnref-1"><a href="#fn-1">1</a></sup>). Given the intentionally naive modification, it increased pre-training time by 33% (wall-clock time) and in the worst case<sup class="footnote-ref" id="fnref-2"><a href="#fn-2">2</a></sup>, inference by up to a factor of 10x<sup class="footnote-ref" id="fnref-3"><a href="#fn-3">3</a></sup>.</p>
<p>However if one were to, hypothetically, entertain the heretical thoughts of straying from The One True Architecture then one could be free of attention's quadratic complexity and worry less about clogging up the context.</p>
<figure>
<img style="width:100%;max-width: 400px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/heretic.webp" ,="" alt="alternative architecture slander as a meme">
<figcaption><i>low effort alternative architecture slander</i></figcaption>
</figure>
<p>In that case, ByT5's kindred soul (w.r.t simplicity) is <a href="https://arxiv.org/abs/2401.13660">MambaByte</a> that capitalises on <a href="https://arxiv.org/abs/2111.00396">State Space Model's</a> (SSM) fixed size memory state that doesn't scale with input context size which, when not dealing with compressed byte representations via subword-level tokenization, becomes a great fit for the problem. However even without the clogged context problem, the sequence length still remains and so do the increased inference steps so they employ the model in a speculative decoding setup to alleviate the burden. SSMs are <a href="https://www.arxiv.org/pdf/2412.11084">a tool in the kit</a> that <a href="https://arxiv.org/abs/2306.15794">have found strong utility</a> where MambaByte would be useful but <a href="https://openreview.net/pdf?id=pymXpl4qvi">they come</a> with their <a href="https://arxiv.org/pdf/2505.15105">own host of challenges</a> that <a href="http://kempnerinstitute.harvard.edu/research/deeper-learning/repeat-after-me-transformers-are-better-than-state-space-models-at-copying/">we inherit</a> when relying on them as the core method to remove the tokenizer.</p>
<p>Alas, given we are True Believers we would never have such thoughts. We hold steady faith in the Values of The Transformer and thus <a href="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/god.webp">heretics we are not</a>.</p>
<h2 id="so-can-we-emlearnem-it">so... can we <em>learn</em> it?</h2><p>In comparison to BPE's learning, there's a series of architecture changes we can make to a transformer to remove the requirement of optimised sub-word tokenization. With the bitter lesson in mind, if we're able to learn tokenization more generally, we would expect to see a model:</p>
<ol>
<li>be competitive or improve loss scores</li>
<li>improve on downstream tasks across the board</li>
<li>demonstrate better scaling curves when thrown more compute and data</li>
</ol>
<p>Before jumping into transformer modifications - are there any directionally relevant changes we can make to vanilla BPE? Mostly, they're incremental changes to compensate for its limitations but aren't aligned with our previously stated goal. It includes things like <a href="https://arxiv.org/pdf/1910.13267">probabilistically skipping merge operations</a> (common in <a href="https://proceedings.mlr.press/v139/ramesh21a.html?ref=journey">a variety</a> of <a href="https://proceedings.mlr.press/v202/radford23a/radford23a.pdf">tasks</a>), a pretokenization curriculum to first learn subwords then <a href="https://arxiv.org/abs/2503.13423">super words that bridge whitespace</a>, falling back to bytes instead of lumping everything into the <code>&lt;unk&gt;</code> token and enforcing <a href="https://arxiv.org/pdf/2103.08490">consistency of predictions</a> over different segmentations. However methods like updating the tokenizer based on <a href="https://aclanthology.org/2020.findings-emnlp.120/">downstream loss under different segmentations</a> and jointly optimizing the <a href="https://aclanthology.org/2021.findings-acl.21/">tokenizer with the model</a> are more aligned with our goal but are trickier to apply in practice.</p>
<p>Given we're seeking generality that demonstrates better scaling curves, this isn't going to cut it.</p>
<h3 id="design-space-so-far">design space so far</h3><p>Rather than going back <a href="https://proceedings.neurips.cc/paper/1995/file/c667d53acd899a97a85de0c201ba99be-Paper.pdf">three decades</a> to paint a deep picture of the space, we'll focus in on the recent progress in the transformer-centric literature where there's been a few different stabs at addressing the efficiency challenges of pure byte modelling for the transformer case.</p>
<p>Each architecture is some variation on the theme of creating a compressed representation which usually materialise in a few choices:</p>
<ol>
<li>down/upsampling to/from that compressed representation</li>
<li>how FLOPS are distributed across levels of representation</li>
<li>decoding strategy <sup class="footnote-ref" id="fnref-4"><a href="#fn-4">4</a></sup></li>
<li>fixed or dynamic width of bytes</li>
</ol>
<p>In language modelling, it's commonplace to compare perplexity but in papers like these where we're not evaluating with a fixed tokenizer, some variation of bits-per-byte will be used as a tokenizer independent version of perplexity:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mo>BPB</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msub><mi>‚Ñí</mi><mrow><mi>C</mi><mi>E</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mi>¬∑</mi><msub><mi>n</mi><mrow><mtext>bytes&nbsp;</mtext></mrow></msub></mrow></mfrac></mrow></math><p>Without getting bogged down in excessive detail, let's consider some directionally-aligned landmark papers in recent memory.</p>
<p><a href="https://arxiv.org/abs/2103.06874">CANINE</a>'s encoder (targeting non-generative tasks) used a combination of n-gram hash embeddings, local attention and strided convolutions to downsample from character-level to a compressed representation processable by a larger transformer <sup class="footnote-ref" id="fnref-5"><a href="#fn-5">5</a></sup>.</p>
<img style="width:100%;max-width: 600px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/canine.webp">
<p><a href="https://arxiv.org/abs/2106.12672">Charformer</a> is an encoder-decoder model that also learns to downsample end-to-end via a gradient-based block scoring function up to some fixed block size<sup class="footnote-ref" id="fnref-6"><a href="#fn-6">6</a></sup>. It isn't designed to be autoregressive either.</p>
<p>Concretely, from the character sequence it builds byte embeddings from which it constructs a series of <em>candidate</em> latent subword blocks up to a max block size at some stride. Stride size is set to the size of block for that block size.</p>
<img style="width:100%;max-width: 400px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/charformer1.webp">
<p>At each position, which latent subword block should we use? This is enabled by a block scoring network to select the right block which gives us a score per block for each position <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>i</mi></mrow></math>. Scores are then softmax'd to get a probability distribution <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>P</mi><mrow><mi>i</mi></mrow></msub></mrow></math> over blocks for position <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>i</mi></mrow></math>. These subword block representations are summed and weighted by their <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>P</mi><mrow><mi>b</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow></math> to form the final latent subword representation for position <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>i</mi></mrow></math>:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mover><mrow><mi>X</mi></mrow><mo stretchy="false">^</mo></mover><mi>i</mi></msub><mo>=</mo><msubsup><mo>‚àë</mo><mi>b</mi><mi>M</mi></msubsup><msub><mi>P</mi><mrow><mi>b</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mi>X</mi><mrow><mi>b</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow></math><p>And visually<sup class="footnote-ref" id="fnref-7"><a href="#fn-7">7</a></sup>:</p>
<img style="width:100%;max-width: 400px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/charformer2.webp">
<p>In its original form (like CANINE), it can't be used in an autoregressive setting due to the downsampling for block scoring since no mask can be applied to ensure no subword is formed with future bytes at each position.</p>
<p>Building off of this, the <a href="https://arxiv.org/abs/2110.13711">Hourglass Transformers</a> paper is a <a href="https://arxiv.org/abs/1505.04597">U-Net-like</a> architecture that shows the success of adapting an autoregressive transformer with downsampling by some static factor at different stages (hence hierarchy in paper title) followed by upsampling with residual connections from the pre-pooled representation<sup class="footnote-ref" id="fnref-8"><a href="#fn-8">8</a></sup>. The down/upsampling are attention-based where they down/upsample the attention's queries via some arbitrary function (respectively average pool, linear upsampling).</p>
<img style="width:100%;max-width: 600px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/hourglass1.webp">
<p>Given they're partially targeting the task of language modelling, they resolve the information leak problem by doing an additional patch-aware shifting of labels to preserve the autoregressive property of the model. They also conduct interesting ablations such as scaling the intermediate layers acting on the downsampled sequence representation (thematically relevant). Crucially though, each time a token is decoded, the entire new sequence has to be passed through the entire network.</p>
<p>They show that they're able to improve upon a baseline byte-level model while still reducing the total number of parameters (at the 150M scale):</p>
<img style="width:100%;max-width: 400px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/hoursglass2.webp">
<p>One of the primary authors extends this architecture and goes on to experiment in <a href="https://arxiv.org/abs/2211.09761">Efficient Transformers with Dynamic Token Pooling</a> to replace the static patching. Given the patch boundary is to be dynamic, they experiment with learning a boundary predictor during training via:</p>
<ol>
<li>supervision via tokenizer (ala CANINE-S<sup class="footnote-ref" id="fnref-5"><a href="#fn-5">5</a></sup>)</li>
<li>supervision via spikes in the conditional entropy of the predictive distribution</li>
<li>end-to-end via stochastic re-parametrisation</li>
</ol>
<p>They also experiment with not learning the boundary predictor and just relying on a modality-specific boundary via the whitespace character.</p>
<p>Just as the previous architecture, it still requires the full model (i.e boundary predictor network, token model and the decoder) to be invoked after each character is decoded<sup class="footnote-ref" id="fnref-9"><a href="#fn-9">9</a></sup>.</p>
<p><a href="https://arxiv.org/abs/2305.07185">MEGABYTE</a>'s multiscale transformers is the next autoregressive approach to look at:</p>
<img style="width:100%;max-width: 500px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/megabyte.webp">
<p>It downsamples from the byte-level by embedding each position in the byte-sequence and chunking it into static patches of length <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>P</mi></mrow></math> and then employing multiscale transformers to model the patch-level and byte-level sequences. If you haven't come across the term "multiscale", much like "hierarchical" in the previous paper, it isn't <a href="https://proceedings.neurips.cc/paper/1995/file/c667d53acd899a97a85de0c201ba99be-Paper.pdf">a new term</a> and it's used here to refer to a large global model that functions on a compressed sequence (i.e patch-level) and a small local model that operates on the full sequence (i.e byte-level). After reviewing the past few papers, hopefully this hierarchy definition should seem familiar.</p>
<p>When thinking about a larger model being triggered by a smaller model and some heuristics, speculative decoding might come to mind<sup class="footnote-ref" id="fnref-10"><a href="#fn-10">10</a></sup>. However if we were to have a byte-level draft model and a byte-level oracle model, it would miss out on the crucial sequence length compression and cripple the global model to have a much shorter max context length.</p>
<p>The core contribution of this paper is this specific separation of computation which impacts the frequency of execution and FLOPs distribution. With a full sequence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>T</mi></mrow></math> bytes and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>P</mi><mo>=</mo><mn>4</mn></mrow></math> at inference time, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>K</mi><mo>=</mo><mfrac><mrow><mi>T</mi></mrow><mrow><mi>P</mi></mrow></mfrac></mrow></math> where the global model is executed <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>K</mi></mrow></math> times (i.e 4x less in this case) versus the local model that runs <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>T</mi></mrow></math> times. The global model is also executed with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>T</mi><mo>/</mo><mn>4</mn></mrow></math> patches in its context putting it in a similar position as the average subword-level token size.</p>
<p>In this setup, the local model is predicting each sequence element's likelihood conditioned <em>solely</em> on its respective patch (and not all previous patches!). In practice, they create <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>K</mi></mrow></math> copies of the local model so that both at prefill (during inference) and training, they're able to parallelise. Its autoregressive property is upheld by, as you would also expect, the inclusion of padding and offsetting inputs to the local and global models to avoid leaking information about future positions.</p>
<p>One of the paper's aim is general, modality-agnostic byte modelling which is demonstrated by their evaluation against language, audio and image modelling<sup class="footnote-ref" id="fnref-11"><a href="#fn-11">11</a></sup>. With respect to language modelling, they show that they outperform other byte-level models in compute-controlled experiments (<a href="https://x.com/karpathy/status/1657949234535211009">to much excitement</a>) but they fail to demonstrate its performance against subword-level transformers in a compute-controlled setting. Given the paper takes on a lot, this seems to have fallen shorter on the list of priorities and so they compared in a compute-variable setting<sup class="footnote-ref" id="fnref-12"><a href="#fn-12">12</a></sup>.</p>
<p>A follow up paper, <a href="https://arxiv.org/abs/2404.14408">SpaceByte</a> demonstrates that when done in a compute-controlled setting alongside subword-level transformers, <a href="https://arxiv.org/html/2404.14408v3#:~:text=0.560-,MegaByte,0.570,-SpaceByte%20">it doesn't perform quite as competitively</a> as the Megabyte authors had figured.</p>
<figure>
<img style="width:100%;max-width: 600px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/pasted-image-20250613080243.webp">
<figcaption><i>unit is bits-per-byte</i></figcaption>
</figure>
<p>Given that <a href="https://arxiv.org/abs/2404.14408">SpaceByte</a> is more fixated on language modelling, they invest more into conducting this benchmarking to have baselines against which to compare. Stemming from the observation that patch boundaries will occur regardless of structure (i.e in the middle of words), they introduce a modality-specific patching rule (ala <a href="https://arxiv.org/abs/2211.09761">hourglass-based dynamic token pooling</a>) that gives rise to dynamic patches (i.e patch on word boundaries via <em>whitespace-like</em> byte characters). In order to handle the dynamic patches, they introduce another local model before the global transformer. In this way, they end up approximating a simpler version of the dynamic patch hourglass transformer in the "whitespace as the dynamic patch boundary predictor" configuration.</p>
<h3 id="back-up-for-a-breather">back up for a breather</h3><p>So where does this leave us?</p>
<p>As mentioned earlier, you'll see that all the architectures are primarily concerned with their down/upsampling method to create a compressed representation upon which they then disproportionately spend FLOPs from their budget. When designing the downsampling scheme, they're also making a choice as to whether the compressed representation will capture a fixed or dynamic width of bytes and how they're going to prevent future position information leakage.</p>
<p>Up until now, byte-level models seem to have found their fit in the wild for specific tasks where the granularity excels like <a href="https://x.com/YiTayML/status/1469023675135369216">toxicity detection</a> which are known to outperform tokenized models on <a href="https://arxiv.org/abs/2106.12672">academic benchmarks</a>. For the "default" case, they haven't seen much adoption. A recent contender has built on all these previous works, invested in proper studies and achieved some interesting results that seem to be best aligned with our previously stated goal.</p>
<hr>
<h2 id="byte-latent-transformer">Byte Latent Transformer</h2><img style="width:100%;max-width: 400px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/9y3fgm.webp">
<p>Using the set of approaches we've accumulated thus far let's break down the BLT. Much like <a href="https://arxiv.org/abs/2404.14408">SpaceByte</a>, it's solely focused on language modelling. Starting with a broad overview of the components, it has:</p>
<ol>
<li>Patcher <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ùí´</mi></mrow></math> that decides the dynamic patch boundaries for a stream of bytes</li>
<li>Local Encoder <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>‚Ñ∞</mi></mrow></math> responsible for going from bytes to patches</li>
<li>Global Transformer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ùí¢</mi></mrow></math> that contextualises the patches</li>
<li>Local Decoder <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ùíü</mi></mrow></math> uses byte-level info from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>‚Ñ∞</mi></mrow></math> and patches from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ùí¢</mi></mrow></math> to predict the next-byte of (what will be) the next patch.</li>
</ol>
<p>Putting that all together into an animation:</p>
<video style="width: 100%" autoplay="" controls="" loop="" muted="" playsinline="">
<source src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/blt-2.mp4" type="video/mp4">
</video>
<p>For most intents and purposes, the animation above should suffice in explaining the architecture to the point that we can investigate the paper's results. For the curious, continue on, for the time-pressed - jump to <a href="#results">the results section</a> or the <a href="#quirks">quirks section</a> that helps build intuition via tinkering.</p>
<h3 id="mechanics">mechanics</h3><p>I'll refer to BLT as the local encoder/decoder + global transformer and the Patcher as a separate entity. The Patcher <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ùí´</mi></mrow></math>'s goal is similar to that in the Hourglass Transformer but rather than using a classifier trained to predict entropy-based patch boundaries, it uses the next-byte prediction of a small byte-level autoregressive LLM's to determine the boundaries via thresholds. Concretely, they're computed as the next byte entropies under the LM distribution <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mi>e</mi></msub></mrow></math> over the byte vocabulary <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ùí±</mi></mrow></math>:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mi>H</mi><mrow><mo stretchy="true" fence="true" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true" fence="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mo>‚àë</mo><mrow><mi>v</mi><mo>‚àà</mo><mi>ùí±</mi></mrow></msub><msub><mi>p</mi><mi>e</mi></msub><mrow><mo stretchy="true" fence="true" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mi>v</mi><mo>‚à£</mo><msub><mi>x</mi><mrow><mo>&lt;</mo><mi>i</mi></mrow></msub><mo stretchy="true" fence="true" form="postfix">)</mo></mrow><mi>log</mi><msub><mi>p</mi><mi>e</mi></msub><mrow><mo stretchy="true" fence="true" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mi>v</mi><mo>‚à£</mo><msub><mi>x</mi><mrow><mo>&lt;</mo><mi>i</mi></mrow></msub><mo stretchy="true" fence="true" form="postfix">)</mo></mrow></mrow></math><p>It's trained separately from the BLT (but on the same pre-training data mix) with sliding window attention (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>n</mi><mrow><mi>c</mi><mi>t</mi><mi>x</mi></mrow></msub><mo>=</mo><mn>512</mn></mrow></math>). A patch boundary is then decided on the basis of either one of two thresholds:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mi>G</mi><mi>l</mi><mi>o</mi><mi>b</mi><mi>a</mi><mi>l</mi><mi>C</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>t</mi><mspace width="1em"></mspace><mi>H</mi><mrow><mo stretchy="true" fence="true" form="prefix">(</mo><msub><mi>x</mi><mi>t</mi></msub><mo stretchy="true" fence="true" form="postfix">)</mo></mrow><mo>&gt;</mo><msub><mi>Œ∏</mi><mrow><mi>g</mi></mrow></msub></mrow></math><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi><mo>.</mo><mi>M</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>t</mi><mi>o</mi><mi>n</mi><mi>i</mi><mi>c</mi><mi>C</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>t</mi><mspace width="1em"></mspace><mi>H</mi><mrow><mo stretchy="true" fence="true" form="prefix">(</mo><msub><mi>x</mi><mi>t</mi></msub><mo stretchy="true" fence="true" form="postfix">)</mo></mrow><mo>‚àí</mo><mi>H</mi><mrow><mo stretchy="true" fence="true" form="prefix">(</mo><msub><mi>x</mi><mrow><mi>t</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><mo stretchy="true" fence="true" form="postfix">)</mo></mrow><mo>&gt;</mo><msub><mi>Œ∏</mi><mi>r</mi></msub></mrow></math><p>The thresholds are calibrated on the basis of the <em>average desired patch size</em> on the pre-training data mix.</p>
<p>For notation, anything subscript <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi></mi><mrow><mi>i</mi></mrow></msub></mrow></math> denotes byte-level positions while <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi></mi><mrow><mi>j</mi></mrow></msub></mrow></math> refers to patch-level.</p>
<p>With patch boundaries defined, the BLT has the Local Encoder <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>‚Ñ∞</mi></mrow></math> that embeds bytes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow></math> via a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mi>‚Ñù</mi><mrow><mn>256</mn><mi>√ó</mi><msub><mi>h</mi><mrow><mi>‚Ñ∞</mi></mrow></msub></mrow></msup></mrow></math> matrix. It has alternating layers of transformer blocks and multi-headed cross attention. It downsamples using <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow></math> and the patch boundaries (from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ùí´</mi></mrow></math>) to create patch representations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mi>j</mi></msub></mrow></math> (ala SpaceByte). <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ùí¢</mi></mrow></math> does a bog-standard pass through the transformer to produce the contextualised <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>o</mi><mrow><mi>j</mi></mrow></msub></mrow></math>. The Local Decoder <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ùíü</mi></mrow></math> also has the alternating layers just in reverse order (i.e starts with cross attention). It uses both enriched patch-level <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>o</mi><mrow><mi>j</mi></mrow></msub></mrow></math> and intermediate byte-level <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mover><mrow><mi>x</mi></mrow><mo stretchy="false">^</mo></mover><mi>i</mi></msub></mrow></math> from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>‚Ñ∞</mi></mrow></math> to predict the next byte <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>b</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></math> of (what will be) the next patch. Prior to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>‚Ñ∞</mi></mrow></math>, a local block causal mask is applied such that byte positions can attend across patch boundaries but not across document boundaries.</p>
<p>Focusing on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>‚Ñ∞</mi></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mover><mrow><mi>x</mi></mrow><mo stretchy="false">^</mo></mover><mrow><mi>i</mi></mrow></msub></mrow></math> is downsampled via pooling that's then projected via a linear layer  <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>‚Ñ∞</mi><mi>C</mi></msub><mo>‚àà</mo><msup><mi>‚Ñù</mi><mrow><msub><mi>h</mi><mrow><mi>‚Ñ∞</mi></mrow></msub><mi>√ó</mi><mrow><mo stretchy="true" fence="true" form="prefix">(</mo><msub><mi>h</mi><mrow><mi>‚Ñ∞</mi></mrow></msub><mi>√ó</mi><msub><mi>U</mi><mrow><mi>‚Ñ∞</mi></mrow></msub><mo stretchy="true" fence="true" form="postfix">)</mo></mrow></mrow></msup></mrow></math> to become <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>Q</mi><mi>j</mi></msub></mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>U</mi><mrow><mi>‚Ñ∞</mi></mrow></msub></mrow></math> is the number of cross attention heads and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mrow><mi>‚Ñ∞</mi></mrow></msub></mrow></math> is the local encoder's embedding dimension. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>Q</mi><mrow><mi>j</mi></mrow></msub></mrow></math> is the patch-level query for the cross attention used in combination with byte-level <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>K</mi><mrow><mi>i</mi></mrow></msub></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>V</mi><mrow><mi>i</mi></mrow></msub></mrow></math> projections of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>x</mi><mrow><mi>i</mi></mrow></msub></mrow></math>. For the cross attention, a special mask is used where each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>Q</mi><mrow><mi>j</mi></mrow></msub></mrow></math> only attends to the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>K</mi></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>V</mi></mrow></math> that corresponds to the bytes in its patch <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>j</mi></mrow></math>.</p>
<p>On the other side, there's <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ùíü</mi></mrow></math> that upsamples by using <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mover><mrow><mi>x</mi></mrow><mo stretchy="false">^</mo></mover><mrow><mi>i</mi></mrow></msub></mrow></math> (i.e last transformer block output) as the byte-level queries and patch-level keys and values via projections of the enriched <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>o</mi><mrow><mi>j</mi></mrow></msub></mrow></math>. Optionally, instead of using <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>x</mi><mrow><mi>i</mi></mrow></msub></mrow></math> directly they imbue each position with CANINE-like n-byte hash embeddings via:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>e</mi><mi>i</mi></msub><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mo>‚àë</mo><mrow><mi>n</mi><mo>=</mo><mn>3</mn><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><mn>8</mn></mrow></msub><msubsup><mi>E</mi><mi>n</mi><mrow><mtext>hash&nbsp;</mtext></mrow></msubsup><mrow><mo stretchy="true" fence="true" form="prefix">(</mo><mo>Hash</mo><mrow><mo stretchy="true" fence="true" form="prefix">(</mo><msub><mi>g</mi><mrow><mi>i</mi><mo>,</mo><mi>n</mi></mrow></msub><mo stretchy="true" fence="true" form="postfix">)</mo></mrow><mo stretchy="true" fence="true" form="postfix">)</mo></mrow></mrow></math><p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow></math> is the position's byte embedding and pushed in space by each n-gram's embedding (i.e here we're adding 6 embeddings to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow></math>). If you want an even more granular pass through the model, <a href="#appendix">the appendix</a> has a concrete forward pass with shapes.</p>
<p>Aligned with our previous analysis of the design space, BLT is attempting to create a more efficient representation while still integrating byte-level information such that the sparingly-run latent transformer <em>can</em> model, on average, more bytes per patch OR reduce a patch down to a single byte per step on particularly difficult problems (i.e low resource languages, reverse spelling etc). Put succinctly:</p>
<blockquote>
<p>"the hypothesis that <a href="https://arxiv.org/html/2412.09871v1#:~:text=the%20hypothesis%20that%20larger%20models%20taking%20fewer%20steps%20on%20larger%20patches%20might%20perform%20better%20than%20smaller%20models%20taking%20more%20steps">larger models taking fewer steps on larger patches</a> might perform better than smaller models taking more steps".</p>
</blockquote>
<h2 id="results">results</h2><p><em>should we even care about understanding this architecture &amp; its quirks more deeply?</em></p>
<p>Using <a href="">the criteria from earlier</a>, let's review the loss results first.</p>
<p>As the old adage goes "if you're getting better results, <a href="https://nonint.com/2023/07/01/techniques-for-debugging-neural-networks/#:~:text=are%20you%20sure%20that%20you%20didn%E2%80%99t%20add%20more%20compute%20to%20your%20NN">are you sure that you didn‚Äôt add more compute to your network?</a>". Hedging against this, they benchmark in compute-controlled settings for non-trivial model sizes (up to 8B and data up to 1T tokens/4T bytes). Importantly, they're comparing against both byte-level and subword-level models (i.e LLaMa 2, 3 and 3.1) which yielded the claim-to-fame graph:</p>
<img style="width:100%;max-width: 700px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/blt-scaling-non-compute-optimal.webp">
<p>In this study with fixed inference FLOPS and trained beyond compute-optimal point (much like Llama 3.1), they're claiming that:</p>
<ol>
<li>BLT generally has a better scaling curve vs LLaMa 2 &amp; 3</li>
<li>Increasing the patch size for BLT gives better scaling curves</li>
</ol>
<p>The second claim seems much weaker in the larger model case and they attribute this weakness to the decreasing share of total FLOPS used by the byte-level local models that seem to scale slower than the global model. If this turns out to be true, it might just be a matter of shifting inference-time FLOPS to the local models and find the right conjoined scaling method. With the first claim, we already satisfy the (1) and (3) criteria we set out so we can move on to (2) criteria.</p>
<p>Sticking with training an 8B beyond compute-optimal point for a 1T token dataset, they show that BLT performs better on most general-interest tasks:</p>
<img style="width:100%;max-width: 600px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/entropy.webp">
<p>The downstream task performance (<a href="https://arxiv.org/html/2412.09871v1#S5.SS3.p4.1:~:text=token%2Dbased%20models.-,6.1,Character%2DLevel%20Tasks,-A%20very%20early">each dataset explained here</a>) focusing on character-level tasks really shines:</p>
<img style="width:100%;max-width: 600px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/general-downstream.webp">
<p>It shows that even a model trained on 16x more data is unable to get anywhere near the performance on simple noised data and basic character-level tasks. To paint a more colourful picture, some examples include:</p>
<img style="width:100%;max-width: 600px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/blt-cute.webp">
<p>Going back to scaling trends, if we maintain the requirement of compute-optimality, they show matching scaling trends:</p>
<img style="width:100%;max-width: 600px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/compute-optimal.webp">
<p>The obvious disclaimers here being that equal training FLOPS != equal wall clock training time given that the implementation of those FLOPS varies. This, in reality, reflects in more expensive trainings given that the <a href="https://github.com/stas00/ml-engineering/blob/master/training/performance/README.md#glossary-and-concepts">Hardware FLOPS Utilisation (HFU)</a> won't be as high and therefore require longer usage. Unfortunately, they don't share any concrete details but, just as we'll <a href="#patch-size-and-flops">see in a bit</a>, 50% less inference FLOPS are on the table which could warrant a slightly more expensive training (much like the current trend to train models beyond compute-optimality for cheaper inference).</p>
<h2 id="quirks">quirks</h2><h3 id="entropy-based-dynamic-patching">entropy-based dynamic patching</h3><p>Even when considering only the entropy-based patching, there are quite a few interesting implications! They train this small byte-level LLM (aka the Patcher) on the same data mix as the BLT model hoping that low/high entropy regions of the Patcher should strongly correlate with that of the BLT<sup class="footnote-ref" id="fnref-13"><a href="#fn-13">13</a></sup>. The implication of this is that the BLT ends up being able to dedicate less compute per byte to less surprising sub-sequences (since more bytes get included into a patch) or more compute to more surprising sub-sequences. Interestingly, this gives the architecture a bounded <a href="https://en.wikipedia.org/wiki/Antifragility">anti-fragile</a> property in that its able to gain (dedicate more compute = better performance) from uncertainty (higher entropy) for OOD or near-OOD events.</p>
<p>Unlike the "less compute" case, the "more compute" case has a hard cap at 1 patch being 1 byte. Given that the less compute (higher compression) case enables the global transformer to be more efficient in the sequence dimension, it's able to squeeze more bytes into the <em>same</em> context length. Since the Patcher (that determines the surprise) is an LLM it also inherits the interesting properties of LLMs where in-context sequences become less surprising and are also further compressed! For the purpose of gaining intuition of this property, tinker around with this HF Space to see how compute will be distributed across your prompt and compare against tiktoken (GPT models) and Llama 3:</p>
<iframe data-src="https://lucalp-blt-entropy-patcher.hf.space" frameborder="0" width="850" height="450" class="lazy-iframe"></iframe>
<p>In the paper, the authors explicitly address this in-context patching with (what I'd regard) a hack of flushing the context window on newlines to avoid "entropy drift" where the designed patching behaviour departs from its desired efficiency/difficulty property but rather <a href="https://arxiv.org/html/2412.09871v1#S5.SS3.p4.1:~:text=For%20example%2C%20%E2%80%9C10%20times%2C%20with%20an%20rms%20deviation%20of%20about%E2%80%9D%20in%20the%20MMLU%20query%20is%20patched%20frequently%20the%20first%20time%20it%20is%20encountered%2C%20but%20is%20part%20of%20very%20large%20patches%20the%20next%20three%20times%2C%20which%2C%20although%20inference%20efficient%2C%20maybe%20undesirable%20for%20reasoning.">impinges on performance</a> in downstream tasks such as MMLU (reasoning):</p>
<img style="width:100%;max-width: 800px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/patching.webp">
<p>As the hack gets addressed, the variable-compression property seems to make this architecture appealing for its harmonious combination with reasoning. Reasoning models are foundational (haha) to current frontier models but they tend to quickly clog up their context window with long reasoning traces<sup class="footnote-ref" id="fnref-14"><a href="#fn-14">14</a></sup> and have to end up spending more tokens for handling issues due to tokenization. I'd be interested to see follow up work a BLT-like architecture with reasoning to see the impact.</p>
<p>Since the average patch size is determined by some threshold, the authors show that they're able to change <a href="https://arxiv.org/html/2412.09871v1#:~:text=However%2C%20with%20BLT,more%20inference%20steps">the patch size at inference time</a> (i.e from a higher threshold to a lower one) so a model trained on larger patches can continue to work on smaller patches. This exists as another lever which can be used on a task-dependent basis. While nice to have at our disposal, we can anticipate it to be quite fragile and its lifetime to be tied to the eventual success of training the entropy patcher in an end-to-end fashion.</p>
<h3 id="patch-size-and-flops">patch size and FLOPS</h3><p>When modulating patch size, it only affects the <em>global model</em>'s FLOPS contribution. The local model's FLOPS contribution won't change since they operate at the byte-level. Taking that into consideration, larger patch sizes at a smaller total BLT model size will cause the local models to make up a more significant share of the total FLOPS. Larger patch should be scaled in tandem with global model's size to properly distribute FLOPS. For this reason at patch size = 8, they're able to grow the total model parameters to be 1.7x its tokenized equivalent for the same inference budget:</p>
<img style="width:100%;max-width: 800px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/blt-crossover.webp">
<p>If you're curious about this relationship between bytes, patch size and model compute, see how the FLOPS distribution changes as you change the parameters:</p>
<iframe src="https://lucalp-byte-latent-transformer-flops.hf.space" frameborder="0" width="850" height="450"></iframe>
<h3 id="n-gram-hash-embeddings">n-gram hash embeddings</h3><p>Surprisingly, the n-gram hash embeddings account for a total embedding table of size <code>shape[3_000_000, 256]</code> since <em>each</em> of the 6 n-gram hash groups has 500K embeddings. They aren't included in the parameter count nor in the FLOPS (as they assume its implemented as an efficient lookup table) which is in line with <a href="https://arxiv.org/abs/2001.08361">OpenAI's scaling laws paper</a>.</p>
<p>But you might be thinking, other LLMs have vocab sizes of 256K and the final linear layer demands non-trivial amounts of FLOPs, why isn't this an issue here? Since these embeddings are used only to nudge the byte-level embeddings by the neighbouring n-grams' embeddings but are never candidates for prediction themselves, the costly linear layer is avoided. They serve as imbuing byte-level positions with some context at no theoretical cost<sup class="footnote-ref" id="fnref-15"><a href="#fn-15">15</a></sup>.</p>
<p>Given the emphasis on the compute-controlled study, I assume that the n-gram hash embeddings are a method of offloading FLOPs from the architecture via feature engineering. In the ablations, <a href="https://nonint.com/2023/06/25/ablations-are-really-important/#:~:text=This%20is%20why%20I%20really%20enjoy%20reading%20the%20ablations%20sections%20of%20any%20research%20paper%3A%20it%20gives%20me%20a%20sense%20for%20what%20actually%20matters%2C%20and%20how%20much%20of%20a%20result%20is%20simply%20due%20to%20the%20implementation%20choices%20a%20researcher%20chose.">one finds clues</a>. For this paper, it's <a href="https://arxiv.org/html/2412.09871v1#S5.SS3.p4.1:~:text=0.850-,False,0.844,-True">Table 9</a> where they're ablating how 10 total local layers should be split amongst the local encoder/decoder. They show that with a sufficiently parametrised local encoder, the n-gram hash embeddings register no meaningful impact<sup class="footnote-ref" id="fnref-16"><a href="#fn-16">16</a></sup>:</p>
<img style="width:100%;max-width: 600px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/ngram-ablation.webp">
<p>Besides their ablations, they claim that at the 8B scale, going from 500K to 300K hashes per group changed performance by 0.001 bpb on 15K steps from which they highlight <a href="https://arxiv.org/html/2412.09871v1#:~:text=At%208B%20scale%20going%20from%20500K%20to%20300K%20hashes%20changed%20performance%20by%20%C2%A00.001%20bpb%20on%2015k%20steps.%20This%20indicates%20that%20hashes%20are%20vital%20to%20bringing%20the%20performance%20of%20BLT%20to%20match%20those%20of%20tokenizer%20based%20models%2C%20however%2C%20after%20300K%20hashes%2C%20there%20are%20diminishing%20returns.">how crucial they are to performance at larger scales</a>. I struggle to follow that conclusion given that their 8B configuration still has <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mi>‚Ñ∞</mi></msub><mo>=</mo><mn>1</mn></mrow></math>. The authors also note that when they're training patch size 8 models, <a href="https://arxiv.org/html/2412.09871v1#S5.SS3.p4.1:~:text=For%20patch%20size%208%20models%2C%20we%20use%203%20encoder%20layers%20instead%20of%201">they're using 3 encoder layers instead of 1</a> giving us an idea as to how quickly the feature engineered n-gram hash embeddings become insufficient.</p>
<h3 id="tokens-to-bytes-in-record-time">tokens to bytes in record time?</h3><p>They run an experiment with initialising the global model from Llama 3.1's weights, train it for 220B tokens with a 10x lower learning rate for the global model than random init'd local models. Once complete, this model would have cumulatively been trained on 15.2T tokens. Presumably, they chose 220B tokens since that's ~1T bytes which was the crossover point in their <a href="https://arxiv.org/html/2412.09871v1#S5.SS3.p4.1:~:text=400B-,1T,-Table%202%3A">fixed inference scaling study</a> against the Llama 3 4B model.</p>
<p>They <a href="https://arxiv.org/html/2412.09871v1#S5.SS3.p4.1:~:text=BLT%20from,%28220B%20tokens%29">compare it</a> against a random init'd BLT (trained on 200B tokens) and the original Llama 3 (trained on 15T tokens) to find that it does <em>worse</em> than the thing it's init'd from <em>but</em> does better than if BLT was trained from scratch:</p>
<img style="width:100%;max-width: 600px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/blt-from-llama.webp">
<p>In the interest of mitigating sunken cost and promoting adoption, this is cool that it "works" but given they come to the conclusion "byte-ifying loses <em>some</em> of the performance" and write it off as "further work needed to take full advantage" and so it isn't a feasible for a "quick" conversion to byte-level. However, if you're one of the big labs wanting to run an experiment to check feasibility of reducing your inference costs without lobotomising your model, this is decent news. If this architecture truly does contribute to unlocking an additional scaling dimension and significantly reduces inference FLOPS, it's probably less important.</p>
<h2 id="implications">implications</h2><p>With supply chain groaning to satisfy the blistering demand for intelligence across the economy, the total share of GPUs for research continues to be under pressure. Until clusters come online, it might mean that in practice less FLOPS at inference is <em>not only</em> a cost reduction measure but rather a means of <a href="https://youtu.be/yTu0ak4GoyM?si=M1hOL3NWMyuUz6K6&amp;t=390">affording more of the FLOPS budget to research</a>!</p>
<p>Even in the event that BLT training is less efficient w.r.t <a href="https://github.com/stas00/ml-engineering/blob/master/training/performance/README.md#glossary-and-concepts">HFU</a>, given this shift to serving being an increasing cost, it might be a tradeoff that carries positive ROI. Consider that mid/post-training has some amount of the training budget dedicated to it to handle lower resource languages, vocab extension, failure of tokenization etc. If a subset of that budget isn't needed and goes to a less efficient HFU BLT training, will it come out to a clear positive ROI?</p>
<p>If the multiscale style architecture proliferates, we'll also see serving change (similar to industrial adoption of spec decoding) given the varying frequency and memory footprint with which these byte-level and patch-level models run. Given their experiments were run against Llama 3 where they almost 2x the dense model parameters, we can only imagine what usage along with <a href="https://arxiv.org/pdf/2412.19437">MoE</a> will do to cluster HBM requirements.</p>
<p>If sequence compression truly is pushed into an end-to-end model, sharing tokenizers as a static entity across models might be a thing of the past <em>but</em> it could be substituted for transfer-learning from patcher/encoder/decoder models into your specific domain. A few more "boring" impacts can be found in <a href="#boring-impacts">the appendix</a>.</p>
<h2 id="future">future</h2><p><em>what does the next iteration look like?</em></p>
<p>With this externalised and separately trained Patcher, BLT still has some BPE-type fragility in that it depends on a component requires its <a href="https://github.com/facebookresearch/blt/issues/106#issuecomment-2863733848">own separate tweaking</a> which might lead it to also become a fragile upstream dependency (but less so than BPE, hopefully).</p>
<p>What does a multi-modal BLT look like? If n-gram hash embeddings have to be replaced, learned modality-specific pre-processing into modality-specific embedding tables could be possible. More than that, I'd expect a deeper encoder but if the need for some additional structured signal remains, possibly some charformer-like GBST block generalised to multiple dimensions might be useful.</p>
<p>Multi modality will require some dynamic patch boundary predictor since the current Patcher LLM is limited to sliding window attention of 512 bytes. In the event where a 640x640 RGB image is over 1 million bytes, this probably breaks down quickly. On this point, I'd expect to see the reliance on flushing context for resolving "entropy drift" to be addressed with a more robust solution or its need completely negated as the Patcher LLM gets integrated or trained jointly with the BLT.</p>
<p><a href="https://www.youtube.com/watch?v=8EIqHFFdccA">In an interview</a>, MEGABYTE's first author (also author on BLT) mentions how they were exploring (at that time) what a multi-scale transformer operating on some pre-tokenized input would look like. Given the lack of mention in the BLT paper, it might have turned out to be a dead end which didn't quite fit in the paper so I'd be less inclined to expect this in the next iteration.</p>
<p>Rather than having this external patch boundary detector and multi scale transformers to handle the dynamic patches, does the desire for adaptive compute leak into the tokenizers directly like in the <a href="https://arxiv.org/pdf/2501.03120">compute adaptive tokenizers paper</a>?</p>
<p>Will the Bitter Lesson prevail? How far will <a href="https://storage.googleapis.com/deepmind-media/gemini/gemini_v2_5_report.pdf">the path</a> of externalised tokenizers with <a href="https://arxiv.org/abs/2405.09818">early fusion on existing architectures</a>take us? Will iterations that increase complexity in the architecture that decouple processing by <a href="https://arxiv.org/abs/2411.04996">modality</a> or possibly by <a href="https://arxiv.org/abs/2505.14683">task</a> find the right balance? If history is our guide and external factors like compute and data continue to trend upwards, we can expect that these will be stepping stones to <a href="https://cdn.prod.website-files.com/5fb8c7611599e6f11e4853cb/6311d521a48397621ae244dc_sutton%20pis.jpg">the Ultimate Architecture</a> (it <a href="https://arxiv.org/abs/1802.08864">might be big</a>).
<br></p>
<img src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/young_frankenstein_end.webp">
<p>Thanks to Christopher Fleetwood, Jochem Gietema, Philip Botros for their feedback on this post.
<br>
<br></p>
<hr>
<h2 id="appendix">appendix</h2><h3 id="blt-granular-mechanics">BLT Granular Mechanics</h3><p>I wanted to think through every step of this model at inference time to fully grok it and had this higher-level pass through already written down. I thought it'd be a shame to not share as there are probably others in the same situation since <a href="https://www.youtube.com/watch?v=loaTGpqfctI">other explanations</a> aren't quite accurate. A useful mental model is that for each patch, we're squeezing out as many bytes as possible until the small autoregressive LLM's (Patcher's) entropy threshold decides that patch has been exhausted. Each patch is <em>not</em> predicted via next token prediction in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mi>G</mi></msub></mrow></math> but rather created by pooling bytes once the Patcher determines a patch boundary.</p>
<p>We can split decoding into two stages - inter-patch prediction and intra-patch prediction. I'm omitting the hash n-gram embeddings from the description. I'll stick to the notation from the paper, worth calling out that anything subscript by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>i</mi></mrow></math> is referencing byte-level, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>j</mi></mrow></math> is referencing patch-level.</p>
<p>For clarity's sake, I'll take a bs=1 scenario mid decoding where we start with the intra-patch decoding case. We have a list of patch lengths&nbsp;<code>[1, 4, 4]</code> determined by the small autoregressive LLM (i.e Patcher).&nbsp;Assuming <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mi>‚Ñ∞</mi></msub><mo>=</mo><mn>256</mn></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>h</mi><mrow><mi>G</mi></mrow></msub><mo>=</mo><mn>1024</mn></mrow></math>, the bytes-level local representation has&nbsp;<code>shape[1, 9, 256]</code>&nbsp;(denoted as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow></math>) and patch-level global representation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>o</mi><mi>j</mi></msub></mrow></math> has&nbsp;already been passed through <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mi>G</mi></msub></mrow></math> and has <code>shape[1, 2, 1024]</code>. Notice how we only have 2 patches even though we have 3 patch lengths.</p>
<p>After sampling to get&nbsp;<code>shape[1, 10]</code> (denoted as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow></math>), the Patcher's entropy threshold isn't reached and so no new patch is determined. We now expect to re-use the patch-level global representation&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mi>j</mi></msub></mrow></math> with <code>shape[1, 2, 1024]</code>.  The next step of the decoder requires the byte-level representation&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>b</mi><mrow><mi>i</mi></mrow></msub></mrow></math> with <code>shape[1, 10]</code>&nbsp;to  be embedded to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow></math> with <code>shape[1, 10, 256]</code>  , go through <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mi>‚Ñ∞</mi></msub></mrow></math> 's transformer blocks to get the latent representation such that it can be used as the Query for the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mrow><mi>D</mi></mrow></msub></mrow></math>'s Cross Attention (CA). Assuming a KV cache exists attached to the CA, we're able to do another full step through the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mi>D</mi></msub></mrow></math>'s CA and transformer layers, and sample the next position so we have a new <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow></math> with<code>shape[1, 11]</code>.</p>
<p>If this turns out to be an end-of-patch event, we have new patch lengths <code>[1, 4, 6]</code>. This is the inter-patch prediction which requires us to get the new <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>o</mi><mi>j</mi></msub></mrow></math> patch representations such that we have a new patch to squeeze out the next set of bytes!</p>
<p>It starts with the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow></math>  <code>shape[1, 11]</code> becoming <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow></math> with <code>shaped[1, 11, 256]</code>, to go through first transformer layer in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mi>‚Ñ∞</mi></msub></mrow></math> into a downsample (i.e pooling), projection to become the patch-based Query for the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mi>‚Ñ∞</mi></msub></mrow></math> CA followed by the rest of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mi>‚Ñ∞</mi></msub></mrow></math>. This gives us a new patch-level representation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>p</mi><mi>j</mi></msub></mrow></math> with <code>shape[1, 3, 1024]</code> that goes through <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mrow><mi>G</mi></mrow></msub></mrow></math>, gets enriched and becomes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>o</mi><mi>j</mi></msub></mrow></math> with <code>shape[1, 3, 1024]</code>  and then a normal <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mi>D</mi></msub></mrow></math> forward pass (i.e with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mi>‚Ñ∞</mi></msub></mrow></math>'s byte-based transformer output skip connection as the Query, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>o</mi><mi>j</mi></msub></mrow></math> as the patch-based KV for the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>l</mi><mi>D</mi></msub></mrow></math>'s CA) from which we can then begin the intra patch decoding via sampling the new first byte position of this provisional patch!</p>
<h3 id="boring-impacts">boring impacts</h3><p>If tokenizers aren't standardised, what does pricing look like? It's structured exactly the same! Patches are just tokens but with variable byte compression and the concept of tokens have such strong customer understanding that if you can avoid introducing new terminology that adds complication to your customer, you would (applies to all but OpenAI with their great model naming conventions). Similarly, even though OpenAI are yet to roll out SLAs, Microsoft's Azure OpenAI Service does have <a href="https://learn.microsoft.com/en-us/azure/ai-services/openai/faq#what-are-the-slas--service-level-agreements--in-azure-openai-">SLAs for latency</a> which wouldn't be materially effected.</p>
<p>It does, however, add a level of obscurity for all model customers given it will be less obvious how you're being charged. Given that pricing obscurity is the norm in that for reasoning, reason traces aren't shown but customers are charged for them, shows that a bit of obscurity isn't a deterrent for adoption.</p>
<h3 id="cite-this-post">cite this post</h3><div class="container-cite">
        <div class="citation-box-plain">
            <button class="copy-btn-plain" id="copyButtonPlain" title="Copy to clipboard"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"></path><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"></path></svg></button>
            <pre><p id="citationTextPlain">@online{lucaperic2025,
  author  = {Luca Periƒá},
  title   = {The Bitter Lesson is coming for Tokenization},
  date    = {2025-06-24},
  url     = {https://lucalp.dev/bitter-lesson-tokenization-and-blt},
  urldate = {2025-07-07}
}</p></pre>
        </div>
    </div>
<h3 id="footnotes">footnotes</h3><section class="footnotes">
<ol>
<li id="fn-1"><p>It's worth noting that there is also mixed findings on these traits for different tasks as <a href="https://arxiv.org/abs/2110.08191">this survey for machine translation</a> "show neither better domain robustness, nor better morphological generalization, despite being often so motivated" but do show "The only clear advantage of character models is high robustness towards source-side noise."<a href="#fnref-1" class="footnote">‚Ü©</a></p></li>
<li id="fn-2"><p>With an imbalanced encoder/decoder setup, inference times are going to vary on the basis of the task type where short inputs and/or long targets are more favourable for a ByT5 encoder-heavy architecture.<a href="#fnref-2" class="footnote">‚Ü©</a></p></li>
<li id="fn-3"><p>In this vein, <a href="https://arxiv.org/abs/2410.20771v3">MrT5</a> addresses the compute problem via introducing token deletion gates to force the model to learn merging input tokens into a more compact sequence, <a href="https://arxiv.org/html/2410.20771v3#:~:text=MrT5%20models%20that%20reduce%20the%20sequence%20length%20by%2050%25%20or%20more%20can%20achieve%2030%25%20speedup%20or%20greater">reducing sequence length by 50% and reaping the speedups</a>. While <a href="https://hkunlp.github.io/blog/2025/evabyte/">EvaByte</a> stays architecturally "simpler" by incorporating multi-byte prediction &amp; a linearized attention variant.<a href="#fnref-3" class="footnote">‚Ü©</a></p></li>
<li id="fn-4"><p>for autoregressive models, guaranteeing no information leakage from future positions<a href="#fnref-4" class="footnote">‚Ü©</a></p></li>
<li id="fn-5"><p>Another model is also evaluated "CANINE-S" where the model uses a tokenizer for pre-training targets for the masked language modelling task.<a href="#fnref-5" class="footnote">‚Ü©</a></p></li>
<li id="fn-6"><p>A note in honour of the authors, this paper seems undeservingly un-cited in the MEGABYTE &amp; Byte Latent Transformer papers<a href="#fnref-6" class="footnote">‚Ü©</a></p></li>
<li id="fn-7"><p>At this point, scores across blocks are independent and so they introduce an optional dot product across all scores to enable the model to consider scores across blocks when weighting the subword block representations. Meaning: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mover><mrow><mi>P</mi></mrow><mo stretchy="false">^</mo></mover><mo>=</mo><mo>softmax</mo><mrow><mo stretchy="true" fence="true" form="prefix">(</mo><mi>P</mi><msup><mi>P</mi><mrow><mo>‚ä§</mo></mrow></msup><mo stretchy="true" fence="true" form="postfix">)</mo></mrow><mi>P</mi></mrow></math><a href="#fnref-7" class="footnote">‚Ü©</a></p></li>
<li id="fn-8"><p>It strongly resembles the work of the <a href="https://arxiv.org/abs/2006.03236">Funnel Transformer</a> but doesn't target the language modelling case - the hourglass paper gets the mention instead given it works autoregressively and the follow up work that closely aligns with this post's design goal.<a href="#fnref-8" class="footnote">‚Ü©</a></p></li>
<li id="fn-9"><p>Follow up work <a href="https://arxiv.org/abs/2311.08620">Toucan</a> removes this requirement for one of the boundary predictor cases by "reusing" the shared representations used to decode each character and they're able to speed up decoding by 2x. <br> <img style="width:100%;max-width: 400px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/pasted-image-20250607123159.webp"><a href="#fnref-9" class="footnote">‚Ü©</a></p></li>
<li id="fn-10"><p>A few of the methods for triggering the oracle's forward pass for verification are:</p><p> </p><ul> <li>static K (i.e after 4 tokens, call oracle model)</li> <li>tuned probability threshold (i.e generate until draft model is not confident)</li> <li><a href="https://arxiv.org/abs/2308.04623">staged speculative decoding</a> or methods where you remove the draft model entirely:</li> <ul> <li><a href="https://lmsys.org/blog/2023-11-21-lookahead-decoding/">lookahead decoding</a></li> <li><a href="https://arxiv.org/abs/2401.10774">Medusa</a>(optionally "lossy" if using self-defined typical sampling)</li> </ul> </ul> <p></p><a href="#fnref-10" class="footnote">‚Ü©</a><p></p></li>
<li id="fn-11"><p>Seemingly, the <a href="https://x.com/liliyu_lili">first author's feed</a> is also an indication of the fixation of freeing modelling multi modality from the tyranny of tokenizers.<a href="#fnref-11" class="footnote">‚Ü©</a></p></li>
<li id="fn-12"><p>"We also compare with the best previously reported numbers for sub-word models. These results may be confounded by differing amounts of compute and tuning used, but show that MEGABYTE gives results competitive with state-of-theart models trained on subwords. These results suggest that MEGABYTE may allow future large language models to be tokenization-free."<a href="#fnref-12" class="footnote">‚Ü©</a></p></li>
<li id="fn-13"><p>they ablate <a href="https://arxiv.org/html/2412.09871v1#S7.F8:~:text=We%20find%20that%20scaling%20performance%20is%20positively%20correlated%20with%20both%20these%20dimensions%20of%20the%20entropy%20model%2C%20with%20diminishing%20returns%20when%20we%20scale%20beyond%2050m%20parameters">model size and context length</a> to see the scaling laws, seeing diminishing returns at 50M. <br> <img style="width:100%;max-width: 400px" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/lucalp/patcher-ablation.webp"><a href="#fnref-13" class="footnote">‚Ü©</a></p></li>
<li id="fn-14"><p>this holds true regardless of whether current models are wasting tokens but this may <a href="https://arxiv.org/pdf/2503.20783">be less of a concern</a> in the future as the RL matures<a href="#fnref-14" class="footnote">‚Ü©</a></p></li>
<li id="fn-15"><p>if they were to use the <a href="https://arxiv.org/abs/2203.15556">DeepMind Chinchilla</a> paper's method, the embeddings FLOPS would be included<a href="#fnref-15" class="footnote">‚Ü©</a></p></li>
<li id="fn-16"><p>It's still valid that increasing encoder layer count will reduce the need for them. It's a bit hard to reason about, their n-gram ablations are all on the basis of encoder layer being set to 1. It seems odd that they don't run ablations with a heavy encoder and a light decoder with no n-gram hash embeddings.<a href="#fnref-16" class="footnote">‚Ü©</a></p></li>
</ol>
</section>


    

    
        

        
            <form id="upvote-form" action="/upvote/DneoHENPEMtzwxeNzfjU/" method="post" style="display: inline">
    <small>
        <input hidden="" name="uid" value="DneoHENPEMtzwxeNzfjU" style="display:none">
        <input hidden="" name="title" style="display:none">
        <input type="hidden" name="csrfmiddlewaretoken" value="wndPkDRFX5045xMkuNFRlTyYzPBarm3BKitHTiaQ33L74GKCgLUBY0fH2FmvCR8A">
        
        <button class="upvote-button" title="Toast this post">
        
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="css-i6dzq1">
                <polyline points="17 11 12 6 7 11"></polyline>
                <polyline points="17 18 12 13 7 18"></polyline>
            </svg>
            <small class="upvote-count">26</small>
        </button>
    </small>        
</form>

<script>
    document.querySelector('#upvote-form').addEventListener('submit', (e) => {
        e.preventDefault();
        const form = e.target;
        fetch(form.action, {
            method: form.method,
            body: new FormData(form),
        });
        const button = form.querySelector('button')
        button.disabled = true
        button.style.color = "salmon"
        const upvoteCount = document.querySelector('.upvote-count')
        upvoteCount.innerHTML = `${(parseInt(upvoteCount.innerHTML.split(" ")[0]) + 1)}`
    });
</script>
        
    


  </main>
  <footer style="padding:25px 0;">
    
    
        <span id="footer-directive">
            <script>
const copyIconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg>`;
const checkIconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/></svg>`;

function getTodaysDate() {
    const today = new Date();
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0'); // Months are 0-indexed
    const day = String(today.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

/**
  * Finds the citation text element and updates its urldate.
  * @param {string} textElementId The ID of the element containing the citation text.
  */
function updateUrlDate(textElementId) {
    const textElement = document.getElementById(textElementId);
    if (!textElement) {
        console.error(`Element with id "${textElementId}" not found.`);
        return;
    }

    const todaysDate = getTodaysDate();
    let originalText = textElement.innerHTML;

    // Use a regular expression to find and replace the urldate value.
    const updatedText = originalText.replace(/(urldate\s*=\s*\{)[^}]+(\})/, `$1${todaysDate}$2`);

    textElement.innerHTML = updatedText;
}


function setupCopyButton(buttonId, textId) {

    const copyButton = document.getElementById(buttonId);
    const citationText = document.getElementById(textId);

    if (!copyButton || !citationText) return;

    // Set initial icon
    copyButton.innerHTML = copyIconSvg;

    copyButton.addEventListener('click', () => {
        const textToCopy = citationText.innerText;

        // Use a temporary textarea to ensure compatibility, especially in iFrames
        const textArea = document.createElement('textarea');
        textArea.value = textToCopy;
        textArea.style.position = 'absolute';
        textArea.style.left = '-9999px';
        document.body.appendChild(textArea);
        textArea.select();

        try {
            document.execCommand('copy');
            // Provide visual feedback
            copyButton.innerHTML = checkIconSvg;
            copyButton.title = "Copied!";
            copyButton.classList.add('copied'); // For plain CSS version

            setTimeout(() => {
                copyButton.innerHTML = copyIconSvg;
                copyButton.title = "Copy to clipboard";
                copyButton.classList.remove('copied');
            }, 2000);
        } catch (err) {
            console.error('Failed to copy text: ', err);
            copyButton.title = "Failed to copy";
        } finally {
            document.body.removeChild(textArea);
        }
    });
}

document.addEventListener('DOMContentLoaded', () => {
    updateUrlDate('citationTextPlain');
    setupCopyButton('copyButtonPlain', 'citationTextPlain');
});
</script>

        </span>
    
    <span>
        Powered by <a href="https://bearblog.dev">Bear  ï‚Ä¢·¥•‚Ä¢ î</a>
    </span>

  </footer>

</body><div id="iframe_container" style="position: fixed; top: 0px; right: 0px; width: 479px; height: 100%; z-index: 2147483647; transition: transform 0.5s ease-in-out; transform: translateX(479px); display: none;"><div class="resizer" style="width: 10px; height: 100%; position: absolute; left: 0px; top: 0px; cursor: ew-resize;"><div style="position: absolute; left: 0px; top: 0px; width: 2px; height: 100%; background: rgba(228, 228, 228, 0.5); cursor: ew-resize;"></div></div><iframe id="iframe_root" style="width: 100%; height: 100%; margin: 0px 0px 0px 2px; border: 0px;"></iframe></div></html>